package leetcode.middle;

/**
 * 给定两个整数 n 和 k，你需要实现一个数组，这个数组包含从 1 到 n 的 n 个不同整数，同时满足以下条件：
 * ① 如果这个数组是 [a1, a2, a3, ... , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数；.
 * ② 如果存在多种答案，你只需实现并返回其中任意一种.
 * 示例 1:
 * 输入: n = 3, k = 1
 * 输出: [1, 2, 3]
 * 解释: [1, 2, 3] 包含 3 个范围在 1-3 的不同整数， 并且 [1, 1] 中有且仅有 1 个不同整数 : 1
 * 示例 2:
 * 输入: n = 3, k = 2
 * 输出: [1, 3, 2]
 * 解释: [1, 3, 2] 包含 3 个范围在 1-3 的不同整数， 并且 [2, 1] 中有且仅有 2 个不同整数: 1 和 2
 * 提示:
 *  n 和 k 满足条件 1 <= k < n <= 104.
 * <p>
 * 解法：
 * 一个数字n和一个数字k，让找出一种排列方式，使得1到n组成的数组中相邻两个数的差的绝对值正好有k种。给了k和n的关系为k<n。那么我们首先来考虑，是否这种条件关系下，是否已定存在这种优美排列呢，我们用一个例子来分析，比如说当n=8，我们有数组：
 * 1, 2, 3, 4, 5, 6, 7, 8
 * 当我们这样有序排列的话，相邻两数的差的绝对值为1。我们想差的绝对值最大能为多少，应该是把1和8放到一起，为7。那么为了尽可能的产生不同的差的绝对值，我们在8后面需要放一个小数字，比如2，这样会产生差的绝对值6，同理，后面再跟一个大数，比如7，产生差的绝对值5，以此类推，我们得到下列数组：
 * 1, 8, 2, 7, 3, 6, 4, 5
 * 其差的绝对值为：7，6，5，4，3，2，1
 * 共有7种，所以我们知道k最大为n-1，所以这样的排列一定会存在。我们的策略是，先按照这种最小最大数相邻的方法排列，没排一个，k自减1，当k减到1的时候，后面的排列方法只要按照生序的方法排列，就不会产生不同的差的绝对值，这种算法的时间复杂度是O(n)，属于比较高效的那种。我们使用两个指针，初始时分别指向1和n，然后分别从i和j取数加入结果res，每取一个数字k自减1，直到k减到1的时候，开始按升序取后面的数字，参见代码如下：
 * https://www.cnblogs.com/grandyang/p/7577878.html
 * 思路：
 * 给定n那么k最大为n-1，假设这k个数字是 n-1,n-2,n-3...1，所以数列可以是1,n-1,2,n-2,....，
 * 比如给定n=9 k=8则数列可以是9 1 8 2 7 3 6 4 5，可以看出这组数据差值是8 7 6 5 4 3 2 1
 * 比如给定n=9 k=4则数列可以是9 1 8 2 3 7 4 6 5，可以看出这组数据差值是8 7 6 1 1 1 1 1
 * https://www.cnblogs.com/wzj4858/p/7678782.html
 * <p>
 * 由题我们可知：1..n最多可以构造出n-1个不同的差，比如 1..9为：[1 9 2 8 3 7 4 6 5]
 * 其相邻元素差的绝对值为：diff: 8 7 6 5 4 3 2 1
 * 观察构造的数据，其是大小交替的。那么这样的话，我们只要先构造出前k个，后面按照顺序来产生1就可以了。
 * 在后面顺序添加的时候注意，需要添加的是增序还是逆序。
 * 如：以1..7为例：
 * k=6：1 7 2 6 3 5 | 4
 * k=5：1 7 2 6 3 | 4 5
 * k=4：1 7 2 6 | 5 4 3
 * k=3：1 7 2 | 3 4 5 6
 * k=2：1 7 | 6 5 4 3 2
 * k=1:1 | 2 3 4 5 6 7
 * https://blog.csdn.net/Koala_Tree/article/details/78494046
 */
public class M667_BeautifulArrangementII {

    /**
     * 举例子，先构造前k个数，后面顺序添加即可
     */
    public int[] constructArray(int n, int k) {
        int[] res = new int[n];
        int l = 1, r = n;
        int i = 0;
        //注意，先填充前 k 个元素
        for (; i < k; i++) {
            if (i % 2 == 0) {
                res[i] = l++;
            } else {
                res[i] = r--;
            }
        }
        if (i % 2 == 0) {
            for (int j = r; j >= l; j--) {
                res[i++] = j;
            }
        } else {
            for (int j = l; j <= r; j++) {
                res[i++] = j;
            }
        }
        return res;
    }
}
