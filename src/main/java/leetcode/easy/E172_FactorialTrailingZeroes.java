package leetcode.easy;

/**
 * 给定一个整数 n，返回 n! 结果尾数中零的数量。
 * 示例 1:
 * 输入: 3
 * 输出: 0
 * 解释: 3! = 6, 尾数中没有零。
 * <p>
 * 示例 2:
 * 输入: 5
 * 输出: 1
 * 解释: 5! = 120, 尾数中有 1 个零.
 * <p>
 * 说明: 你算法的时间复杂度应为 O(log n) 。
 */
public class E172_FactorialTrailingZeroes {
    /**
     * 观察一下，5 的阶乘结果是 120，零的个数为 1：
     * 5! = 5 * 4 * 3 * 2 * 1 = 120
     * 末尾唯一的零来自于 2 * 5。很显然，如果需要产生零，阶乘中的数需要包含 2 和 5 这两个因子。
     * 例如：4 * 10 = 40 也会产生零，因为 4 * 10 = ( 2 * 2 ) * ( 2 * 5) 。
     * 因此，我们只要数一数组成阶乘的数中共有多少对 2 和 5 的组合即可。又因为 5 的个数一定比 2 少，问题简化为计算 5 的个数就可以了。
     * <p>
     * 为什么 2 更多？
     * 因为是阶乘，其中 5 的个数一定比 2 要少，如果已经阶乘到 25 了，前面已经有非常多个 2 可以与它相匹配了，毕竟只要是偶数就会有 2 这个因子。
     */
    public int trailingZeroes(int n) {
        int res = 0;
        while (n >= 5) {
            res += n / 5;
            n /= 5;
        }
        return res;
    }
}
